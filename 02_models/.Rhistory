n_bins = n_bins
# Apply log transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
data$var1 = log(data[[params[1]]])
} else {
data$var1 = data[[params[1]]]
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
data$var2 = log(data[[params[2]]])
} else {
data$var2 = data[[params[2]]]
}
# Calculate min and max for both parameters
min_x = min(data$var1, na.rm = TRUE)
max_x = max(data$var1, na.rm = TRUE)
min_y = min(data$var2, na.rm = TRUE)
max_y = max(data$var2, na.rm = TRUE)
# Define dynamic block sizes
block_size_x = (max_x - min_x) / n_bins
block_size_y = (max_y - min_y) / n_bins
# Convert selected_output to a symbol
selected_output_sym = ensym(selected_output)
res = data %>%
mutate(
V1 = cut(data$var1, breaks = seq(min_x, max_x, by = block_size_x), include.lowest = TRUE),
V2 = cut(data$var2, breaks = seq(min_y, max_y, by = block_size_y), include.lowest = TRUE)
) %>%
group_by(V1, V2) %>%
summarise(output_avg = mean(!!selected_output_sym, na.rm = TRUE), .groups = 'drop') %>%
ungroup() %>%
mutate(
# Use str_extract to extract the first numeric value from V1 and V2
x_mid = as.numeric(str_extract(V1, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_x / 2,
y_mid = as.numeric(str_extract(V2, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_y / 2
)
# Apply exp transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
res$x_mid = exp(res$x_mid)
} else {
res$x_mid = res$x_mid
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
res$y_mid = exp(res$y_mid)
} else {
res$y_mid = res$y_mid
}
return(res)
res
create_binned_data(data = simulation_dt %>% subset(., scenario == scenario_1),
params = evaluated_parameter,
param_ranges = param_ranges,
selected_output = selected_output,
n_bins = n_bins)
setwd("C:/Data/1_Adminitratif/Emploi/cornell/02_projet/hpai_mitigation/02_models")
library(tidyverse)
library(ggplot2)
library(reshape2)
library(abind)
library(cowplot)
source("model.R")
library(lhs)
library(ggplot2)
library(dplyr)
library(stringr)
library(rlang)
source("param_ranges.R")
source("scenarios.R")
# source("sampling.R")
load("simulation_dt/simulation_dt_50_2.RData")
# Number of bins (same for both dimensions)
N_BINS = 10
evaluated_parameter = c("beta_I_colony", "reaching_repro_prob")
plotted_scenario = "BO"
data = simulation_dt %>% subset(., scenario == "BO")
SELECTED_OUTPUT = "nb_infected_colonies"
data = simulation_dt %>% subset(., scenario == scenario_1)
params = evaluated_parameter
param_ranges = param_ranges
selected_output = selected_output
n_bins = n_bins
create_binned_data()
data = simulation_dt %>% subset(., scenario == scenario_1)
params = evaluated_parameter
param_ranges = param_ranges
selected_output = selected_output
n_bins = N_BINS
# Function to create binned data with dynamic parameters and variable block sizes
create_binned_data = function(data = simulation_dt %>% subset(., scenario == scenario_1),
params = evaluated_parameter,
param_ranges = param_ranges,
selected_output = selected_output,
n_bins = n_bins) {
# Apply log transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
data$var1 = log(data[[params[1]]])
} else {
data$var1 = data[[params[1]]]
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
data$var2 = log(data[[params[2]]])
} else {
data$var2 = data[[params[2]]]
}
# Calculate min and max for both parameters
min_x = min(data$var1, na.rm = TRUE)
max_x = max(data$var1, na.rm = TRUE)
min_y = min(data$var2, na.rm = TRUE)
max_y = max(data$var2, na.rm = TRUE)
# Define dynamic block sizes
block_size_x = (max_x - min_x) / n_bins
block_size_y = (max_y - min_y) / n_bins
# Convert selected_output to a symbol
selected_output_sym = ensym(selected_output)
res = data %>%
mutate(
V1 = cut(data$var1, breaks = seq(min_x, max_x, by = block_size_x), include.lowest = TRUE),
V2 = cut(data$var2, breaks = seq(min_y, max_y, by = block_size_y), include.lowest = TRUE)
) %>%
group_by(V1, V2) %>%
summarise(output_avg = mean(!!selected_output_sym, na.rm = TRUE), .groups = 'drop') %>%
ungroup() %>%
mutate(
# Use str_extract to extract the first numeric value from V1 and V2
x_mid = as.numeric(str_extract(V1, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_x / 2,
y_mid = as.numeric(str_extract(V2, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_y / 2
)
# Apply exp transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
res$x_mid = exp(res$x_mid)
} else {
res$x_mid = res$x_mid
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
res$y_mid = exp(res$y_mid)
} else {
res$y_mid = res$y_mid
}
return(res)
}
create_binned_data(data = simulation_dt %>% subset(., scenario == scenario_1),
params = evaluated_parameter,
param_ranges = param_ranges,
selected_output = selected_output,
n_bins = n_bins)
create_binned_data(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter,
param_ranges = param_ranges,
selected_output = selected_output,
n_bins = n_bins)
data = simulation_dt %>% subset(., scenario == scenario_1)
data = simulation_dt %>% subset(., scenario == "BO")
params = evaluated_parameter
param_ranges = param_ranges
selected_output = selected_output
n_bins = N_BINS
# Apply log transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
data$var1 = log(data[[params[1]]])
} else {
data$var1 = data[[params[1]]]
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
data$var2 = log(data[[params[2]]])
} else {
data$var2 = data[[params[2]]]
}
# Calculate min and max for both parameters
min_x = min(data$var1, na.rm = TRUE)
max_x = max(data$var1, na.rm = TRUE)
min_y = min(data$var2, na.rm = TRUE)
max_y = max(data$var2, na.rm = TRUE)
# Define dynamic block sizes
block_size_x = (max_x - min_x) / n_bins
block_size_y = (max_y - min_y) / n_bins
# Convert selected_output to a symbol
selected_output_sym = ensym(selected_output)
res = data %>%
mutate(
V1 = cut(data$var1, breaks = seq(min_x, max_x, by = block_size_x), include.lowest = TRUE),
V2 = cut(data$var2, breaks = seq(min_y, max_y, by = block_size_y), include.lowest = TRUE)
) %>%
group_by(V1, V2) %>%
summarise(output_avg = mean(!!selected_output_sym, na.rm = TRUE), .groups = 'drop') %>%
ungroup() %>%
mutate(
# Use str_extract to extract the first numeric value from V1 and V2
x_mid = as.numeric(str_extract(V1, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_x / 2,
y_mid = as.numeric(str_extract(V2, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_y / 2
)
selected_output
# Number of bins (same for both dimensions)
N_BINS = 10
evaluated_parameter = c("beta_I_colony", "reaching_repro_prob")
plotted_scenario = "BO"
data = simulation_dt %>% subset(., scenario == "BO")
SELECTED_OUTPUT = "nb_infected_colonies"
data = simulation_dt %>% subset(., scenario == "BO")
params = evaluated_parameter
param_ranges = param_ranges
selected_output = SELECTED_OUTPUT
n_bins = N_BINS
# Function to create binned data with dynamic parameters and variable block sizes
create_binned_data = function(data = simulation_dt %>% subset(., scenario == scenario_1),
params = evaluated_parameter,
param_ranges = param_ranges,
selected_output = selected_output,
n_bins = n_bins) {
# Apply log transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
data$var1 = log(data[[params[1]]])
} else {
data$var1 = data[[params[1]]]
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
data$var2 = log(data[[params[2]]])
} else {
data$var2 = data[[params[2]]]
}
# Calculate min and max for both parameters
min_x = min(data$var1, na.rm = TRUE)
max_x = max(data$var1, na.rm = TRUE)
min_y = min(data$var2, na.rm = TRUE)
max_y = max(data$var2, na.rm = TRUE)
# Define dynamic block sizes
block_size_x = (max_x - min_x) / n_bins
block_size_y = (max_y - min_y) / n_bins
# Convert selected_output to a symbol
selected_output_sym = ensym(selected_output)
res = data %>%
mutate(
V1 = cut(data$var1, breaks = seq(min_x, max_x, by = block_size_x), include.lowest = TRUE),
V2 = cut(data$var2, breaks = seq(min_y, max_y, by = block_size_y), include.lowest = TRUE)
) %>%
group_by(V1, V2) %>%
summarise(output_avg = mean(!!selected_output_sym, na.rm = TRUE), .groups = 'drop') %>%
ungroup() %>%
mutate(
# Use str_extract to extract the first numeric value from V1 and V2
x_mid = as.numeric(str_extract(V1, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_x / 2,
y_mid = as.numeric(str_extract(V2, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_y / 2
)
# Apply exp transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
res$x_mid = exp(res$x_mid)
} else {
res$x_mid = res$x_mid
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
res$y_mid = exp(res$y_mid)
} else {
res$y_mid = res$y_mid
}
return(res)
}
create_binned_data(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter,
param_ranges = param_ranges,
selected_output = selected_output,
n_bins = n_bins)
# Apply log transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
data$var1 = log(data[[params[1]]])
} else {
data$var1 = data[[params[1]]]
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
data$var2 = log(data[[params[2]]])
} else {
data$var2 = data[[params[2]]]
}
# Calculate min and max for both parameters
min_x = min(data$var1, na.rm = TRUE)
max_x = max(data$var1, na.rm = TRUE)
min_y = min(data$var2, na.rm = TRUE)
max_y = max(data$var2, na.rm = TRUE)
# Define dynamic block sizes
block_size_x = (max_x - min_x) / n_bins
block_size_y = (max_y - min_y) / n_bins
# Convert selected_output to a symbol
selected_output_sym = ensym(selected_output)
res = data %>%
mutate(
V1 = cut(data$var1, breaks = seq(min_x, max_x, by = block_size_x), include.lowest = TRUE),
V2 = cut(data$var2, breaks = seq(min_y, max_y, by = block_size_y), include.lowest = TRUE)
) %>%
group_by(V1, V2) %>%
summarise(output_avg = mean(!!selected_output_sym, na.rm = TRUE), .groups = 'drop') %>%
ungroup() %>%
mutate(
# Use str_extract to extract the first numeric value from V1 and V2
x_mid = as.numeric(str_extract(V1, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_x / 2,
y_mid = as.numeric(str_extract(V2, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_y / 2
)
# Apply exp transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
res$x_mid = exp(res$x_mid)
} else {
res$x_mid = res$x_mid
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
res$y_mid = exp(res$y_mid)
} else {
res$y_mid = res$y_mid
}
res
# Number of bins (same for both dimensions)
N_BINS = 10
evaluated_parameter = c("beta_I_colony", "reaching_repro_prob")
plotted_scenario = "BO"
data = simulation_dt %>% subset(., scenario == "BO")
SELECTED_OUTPUT = "nb_infected_colonies"
data = simulation_dt %>% subset(., scenario == "BO")
params = evaluated_parameter
param_ranges = param_ranges
selected_output = SELECTED_OUTPUT
n_bins = N_BINS
# Function to create binned data with dynamic parameters and variable block sizes
create_binned_data = function(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter,
param_ranges = param_ranges,
selected_output = SELECTED_OUTPUT,
n_bins = N_BINS) {
# Apply log transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
data$var1 = log(data[[params[1]]])
} else {
data$var1 = data[[params[1]]]
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
data$var2 = log(data[[params[2]]])
} else {
data$var2 = data[[params[2]]]
}
# Calculate min and max for both parameters
min_x = min(data$var1, na.rm = TRUE)
max_x = max(data$var1, na.rm = TRUE)
min_y = min(data$var2, na.rm = TRUE)
max_y = max(data$var2, na.rm = TRUE)
# Define dynamic block sizes
block_size_x = (max_x - min_x) / n_bins
block_size_y = (max_y - min_y) / n_bins
# Convert selected_output to a symbol
selected_output_sym = ensym(selected_output)
res = data %>%
mutate(
V1 = cut(data$var1, breaks = seq(min_x, max_x, by = block_size_x), include.lowest = TRUE),
V2 = cut(data$var2, breaks = seq(min_y, max_y, by = block_size_y), include.lowest = TRUE)
) %>%
group_by(V1, V2) %>%
summarise(output_avg = mean(!!selected_output_sym, na.rm = TRUE), .groups = 'drop') %>%
ungroup() %>%
mutate(
# Use str_extract to extract the first numeric value from V1 and V2
x_mid = as.numeric(str_extract(V1, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_x / 2,
y_mid = as.numeric(str_extract(V2, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_y / 2
)
# Apply exp transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
res$x_mid = exp(res$x_mid)
} else {
res$x_mid = res$x_mid
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
res$y_mid = exp(res$y_mid)
} else {
res$y_mid = res$y_mid
}
return(res)
}
create_binned_data(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter,
param_ranges = param_ranges,
selected_output = selected_output,
n_bins = n_bins)
create_binned_data()
create_binned_data(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter,
param_ranges = param_ranges,
selected_output = selected_output,
n_bins)
create_binned_data(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter,
param_ranges = param_ranges,
selected_output,
n_bins)
create_binned_data(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter,
param_ranges = param_ranges)
create_binned_data(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter)
create_binned_data(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter,
param_ranges = param_ranges)
param_ranges
# Function to create binned data with dynamic parameters and variable block sizes
create_binned_data = function(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter,
param_ranges,
selected_output = SELECTED_OUTPUT,
n_bins = N_BINS) {
# Apply log transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
data$var1 = log(data[[params[1]]])
} else {
data$var1 = data[[params[1]]]
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
data$var2 = log(data[[params[2]]])
} else {
data$var2 = data[[params[2]]]
}
# Calculate min and max for both parameters
min_x = min(data$var1, na.rm = TRUE)
max_x = max(data$var1, na.rm = TRUE)
min_y = min(data$var2, na.rm = TRUE)
max_y = max(data$var2, na.rm = TRUE)
# Define dynamic block sizes
block_size_x = (max_x - min_x) / n_bins
block_size_y = (max_y - min_y) / n_bins
# Convert selected_output to a symbol
selected_output_sym = ensym(selected_output)
res = data %>%
mutate(
V1 = cut(data$var1, breaks = seq(min_x, max_x, by = block_size_x), include.lowest = TRUE),
V2 = cut(data$var2, breaks = seq(min_y, max_y, by = block_size_y), include.lowest = TRUE)
) %>%
group_by(V1, V2) %>%
summarise(output_avg = mean(!!selected_output_sym, na.rm = TRUE), .groups = 'drop') %>%
ungroup() %>%
mutate(
# Use str_extract to extract the first numeric value from V1 and V2
x_mid = as.numeric(str_extract(V1, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_x / 2,
y_mid = as.numeric(str_extract(V2, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_y / 2
)
# Apply exp transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
res$x_mid = exp(res$x_mid)
} else {
res$x_mid = res$x_mid
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
res$y_mid = exp(res$y_mid)
} else {
res$y_mid = res$y_mid
}
return(res)
}
create_binned_data(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter,
param_ranges = param_ranges)
create_binned_data(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter)
# Function to create binned data with dynamic parameters and variable block sizes
create_binned_data = function(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter,
param_ranges,
selected_output = SELECTED_OUTPUT,
n_bins = N_BINS) {
# Apply log transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
data$var1 = log(data[[params[1]]])
} else {
data$var1 = data[[params[1]]]
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
data$var2 = log(data[[params[2]]])
} else {
data$var2 = data[[params[2]]]
}
# Calculate min and max for both parameters
min_x = min(data$var1, na.rm = TRUE)
max_x = max(data$var1, na.rm = TRUE)
min_y = min(data$var2, na.rm = TRUE)
max_y = max(data$var2, na.rm = TRUE)
# Define dynamic block sizes
block_size_x = (max_x - min_x) / n_bins
block_size_y = (max_y - min_y) / n_bins
# Convert selected_output to a symbol
selected_output_sym = ensym(selected_output)
res = data %>%
mutate(
V1 = cut(data$var1, breaks = seq(min_x, max_x, by = block_size_x), include.lowest = TRUE),
V2 = cut(data$var2, breaks = seq(min_y, max_y, by = block_size_y), include.lowest = TRUE)
) %>%
group_by(V1, V2) %>%
summarise(output_avg = mean(!!selected_output_sym, na.rm = TRUE), .groups = 'drop') %>%
ungroup() %>%
mutate(
# Use str_extract to extract the first numeric value from V1 and V2
x_mid = as.numeric(str_extract(V1, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_x / 2,
y_mid = as.numeric(str_extract(V2, "[-+]?[0-9]*\\.?[0-9]+")) + block_size_y / 2
)
# Apply exp transformation if specified
if (param_ranges[[params[1]]][[2]] == "logarithmic") {
res$x_mid = exp(res$x_mid)
} else {
res$x_mid = res$x_mid
}
if (param_ranges[[params[2]]][[2]] == "logarithmic") {
res$y_mid = exp(res$y_mid)
} else {
res$y_mid = res$y_mid
}
return(res)
}
create_binned_data(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter)
create_binned_data(data = simulation_dt %>% subset(., scenario == "BO"),
params = evaluated_parameter,
param_ranges = param_ranges)
create_binned_data(param_ranges = param_ranges)
create_binned_data(param_ranges = param_ranges)
